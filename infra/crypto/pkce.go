package crypto

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"

	"userclouds.com/infra/ucerr"
)

// This file contains helper routines for use in Proof Key Code Exchange:
// https://datatracker.ietf.org/doc/html/rfc7636

// CodeVerifier is a cryptographically random string that can vary from
// 43 to 128 characters in length which is generated by base64url-encoding
// an octet/byte sequence.
type CodeVerifier string

// DefaultCodeVerifierByteLength is the default length in bytes of UC-generated code verifier.
// In practice, 43 chars (encoded from 32 bytes) is sufficient to not be
// brute-forced in the limited time intervals that auth codes are valid.
const DefaultCodeVerifierByteLength = 32

// Min and max lengths of base64url encoded code verifier strings (no padding).
// 32 bytes = 43 base64 chars (min)
// Clients can generate up to 128 base64 chars (96 bytes) as their code_verifier,
// so the server needs to support that.
const (
	MinCodeVerifierBase64Length = 43
	MaxCodeVerifierBase64Length = 128
)

// CodeChallengeLength is the expected code challenge length. According to the spec, it can be between
// [43, 128] but since we only support 'S256' (SHA 256) as the verifier method, it *must* be 43 because
// ase64 encoding of a 32-byte SHA digest without padding always produces 43 characters. If we supported
// 'plain' verifiers then we could theoretically have 43 to 128 chars depending on the Code Verifier
// length chosen by the client (because challenge == verifier with 'plain').
const CodeChallengeLength = 43

// CodeChallengeMethod represents a valid 'code_challenge_method' for PKCE.
type CodeChallengeMethod int

// Supported Code Challenge Methods for PKCE.
const (
	CodeChallengeMethodInvalid CodeChallengeMethod = 0
	CodeChallengeMethodS256    CodeChallengeMethod = 1
)

//go:generate genconstant CodeChallengeMethod

// NewCodeChallengeMethod parses a method by name and returns a CodeChallengeMethod
func NewCodeChallengeMethod(method string) (CodeChallengeMethod, error) {
	switch method {
	case "S256":
		return CodeChallengeMethodS256, nil
	}
	return CodeChallengeMethodInvalid, ucerr.Errorf("unsupported code challenge method: %s", method)
}

// ValidateCodeChallenge ensures that a code challenge is potentially valid given a method
func ValidateCodeChallenge(method CodeChallengeMethod, codeChallenge string) error {
	switch method {
	case CodeChallengeMethodS256:
		if len(codeChallenge) != CodeChallengeLength {
			return ucerr.New("when using 'S256', 'code_challenge' must be 43 base64url encoded characters")
		}
		return nil
	}
	return ucerr.Errorf("unsupported code challenge method: %s", method.String())
}

// NewCodeVerifier generates a cryptographically random code verifier string
// for use in Authorization Code with PKCE flows.
func NewCodeVerifier() CodeVerifier {
	b := make([]byte, DefaultCodeVerifierByteLength)
	if _, err := rand.Read(b); err != nil {
		// If this fails it's not likely recoverable.
		panic(err)
	}
	return CodeVerifier(base64.RawURLEncoding.EncodeToString(b))
}

// GetCodeChallenge generates the (unique) code challenge from a code verifier.
func (c CodeVerifier) GetCodeChallenge(method CodeChallengeMethod) (string, error) {
	switch method {
	case CodeChallengeMethodS256:
		hash := sha256.Sum256([]byte(c))
		return base64.RawURLEncoding.EncodeToString(hash[:]), nil
	}
	return "", ucerr.Errorf("unsupported code challenge method: %s", method.String())
}
