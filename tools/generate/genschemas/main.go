package genschemas

import (
	"context"
	"fmt"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"golang.org/x/tools/go/packages"

	"userclouds.com/infra/migrate"
	"userclouds.com/infra/testdb"
	"userclouds.com/infra/ucerr"
	"userclouds.com/infra/uclog"
	"userclouds.com/internal/companyconfig"
	"userclouds.com/internal/tenantdb"
	"userclouds.com/tools/generate"
)

// Run implements the generator interface
func Run(ctx context.Context, p *packages.Package, path string, args ...string) {
	_, connStr, containerName, _ := StartTemporaryPostgres(ctx, fmt.Sprintf("%s-genschemas", p.Name), 543)
	defer func() {
		if err := exec.Command("docker", "rm", "-f", containerName).Run(); err != nil {
			uclog.Errorf(ctx, "error removing container %s: %v", containerName, err)
		}
	}()

	uclog.Infof(ctx, "Processing package %s", p.Name)
	var dbName string
	var postgresExtensions []string

	// TODO: there's probably a more clever way to do this but...
	if p.Name == "tenantdb" {
		_, dbName = testdb.NewWithConnStr(testingMock{}, connStr, migrate.NewTestSchema(tenantdb.SchemaBaseline), migrate.NewTestMigrator(tenantdb.GetMigrations()))
		postgresExtensions = tenantdb.SchemaBaseline.PostgresOnlyExtensions
	} else if p.Name == "companyconfig" {
		_, dbName = testdb.NewWithConnStr(testingMock{}, connStr, migrate.NewTestSchema(companyconfig.SchemaBaseline), migrate.NewTestMigrator(companyconfig.GetMigrations()))
	} else {
		uclog.Infof(ctx, "No migrations found to collapse for %s ", p.Name)
	}
	if err := saveSchema(ctx, p, path, postgresExtensions, containerName, dbName); err != nil {
		uclog.Fatalf(ctx, "error saving schema: %v", err)
	}
}

func saveSchema(ctx context.Context, p *packages.Package, path string, postgresExtensions []string, containerName string, dbName string) error {
	out, err := exec.Command("docker", "exec", containerName, "pg_dump", "-s", "-U", "postgres", dbName).Output()
	if err != nil {
		return ucerr.Wrap(err)
	}

	// filter out SET, SELECT, and owner-changing statements and standardize comment lines
	var filteredLines []string
	for line := range strings.SplitSeq(string(out), "\n") {
		if strings.HasPrefix(line, "SET") || strings.HasPrefix(line, "SELECT") || strings.Contains(line, "OWNER TO") {
			continue
		}
		if strings.HasPrefix(line, "--") {
			filteredLines = append(filteredLines, "--")
			continue
		}
		filteredLines = append(filteredLines, line)
	}
	filteredOut := []byte(strings.Join(filteredLines, "\n"))

	// split on -- and trim each statement
	var statements []string
	for statement := range strings.SplitSeq(string(filteredOut), "--") {
		statement = strings.TrimSpace(statement)
		if statement == "" {
			continue
		}
		statements = append(statements, fmt.Sprintf("`%s`", statement))
	}

	// render them to a codegen'd .go file
	type data struct {
		Package            string
		Schemas            []string
		PostgresExtensions []string
	}
	d := data{
		Package:            p.Name,
		Schemas:            statements,
		PostgresExtensions: postgresExtensions,
	}
	fn := filepath.Join(path, "schema_generated.go")
	generate.WriteFileIfChanged(ctx, fn, templateString, d)
	return nil
}

var templateString = `// NOTE: automatically generated file -- DO NOT EDIT

package << .Package >>

import "userclouds.com/infra/migrate"

// these schemas are autogenerated to match all the applied migrations for test perf

// Schema defines the database schema for this package
var Schema = migrate.Schema{
	Migrations:       Migrations,
	CreateStatements: schemas,
	Columns:          UsedColumns,
	PostgresOnlyExtensions: []string{
		<<- range $e := .PostgresExtensions >>
		"<< $e >>",
		<<- end >>
	},
}

var schemas = []string{
	<<- range $s := .Schemas >>
	<< $s >>,
	<<- end >>
}
`

// so we can use testdb to manage this process
type testingMock struct {
	testing.TB
}

// Cleanup implements testing.TB
func (t testingMock) Cleanup(_ func()) {}
