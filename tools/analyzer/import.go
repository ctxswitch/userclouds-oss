package analyzer

import (
	"go/ast"
	"strconv"
	"strings"

	"golang.org/x/tools/go/analysis"
	"golang.org/x/tools/go/ast/astutil"

	"userclouds.com/infra/ucerr"
)

var ourPackageDomain = "userclouds.com"

// ImportAnalyzer checks that our import statements are grouped correctly.
var ImportAnalyzer = &analysis.Analyzer{
	Name: "checkimports",
	Doc:  "checks import ordering",
	Run:  runImportAnalysis,
}

type importState int

const (
	stateStart importState = iota
	stateStd
	stateThirdParty
	stateFirstParty
)

func (s *importState) Check(pass *analysis.Pass, first bool, imp *ast.ImportSpec) error {
	if *s > stateFirstParty {
		pass.Reportf(imp.Pos(), "too many import groups: should be stdlib, third-party, then %s", ourPackageDomain)
		return nil
	}
	path, err := strconv.Unquote(imp.Path.Value)
	if err != nil {
		return ucerr.Errorf("%v: %v", pass.Fset.Position(imp.Pos()), err)
	}
	actual := stateThirdParty
	if !strings.Contains(path, ".") {
		actual = stateStd
	} else if strings.HasPrefix(path, ourPackageDomain) {
		actual = stateFirstParty
	}
	// If this is the first import in a paragraph, we can skip groups.
	if first && actual > *s {
		*s = actual
		return nil
	}
	if actual != *s {
		pass.Reportf(imp.Pos(), "imports should be grouped into stdlib, third-party, then %s", ourPackageDomain)
	}
	return nil
}

// isGeneratedTestFile checks whether the file was generated by `go test`. We
// don't control these files and shouldn't lint them.
func isGeneratedTestFile(f *ast.File) bool {
	// All generated code is in package main, so we're stuck looking for this
	// sentinel file-level comment.
	for _, c := range f.Comments {
		if strings.Contains(c.Text(), "Code generated by 'go test'. DO NOT EDIT.") {
			return true
		}
	}
	return false
}

func runImportAnalysis(pass *analysis.Pass) (any, error) {
	for _, file := range pass.Files {
		if isGeneratedTestFile(file) {
			continue
		}
		var state importState
		for _, group := range astutil.Imports(pass.Fset, file) {
			state++ // each paragraph should advance state
			for idx, imp := range group {
				if err := state.Check(pass, idx == 0, imp); err != nil {
					return nil, ucerr.Errorf("%v: %v", pass.Fset.Position(imp.Pos()), err)
				}
			}
		}

		// also prevent infra from referencing internal
		// TODO: enable this when we have time to fix the ~25 extant references
		// fn := pass.Fset.Position(file.Pos()).Filename
		// if strings.Contains(fn, strings.TrimSuffix(ourPackageDomain, ".com")) && strings.Contains(fn, "/infra/") {
		// 	for _, group := range astutil.Imports(pass.Fset, file) {
		// 		for _, imp := range group {
		// 			if strings.Contains(imp.Path.Value, "internal") {
		// 				pass.Reportf(imp.Pos(), "file in %s/infra imports package from %s/internal", ourPackageDomain, ourPackageDomain)
		// 			}
		// 		}
		// 	}
		// }
	}
	return nil, nil
}
