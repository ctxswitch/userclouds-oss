package main

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"sync"

	"github.com/gofrs/uuid"
	"github.com/google/go-cmp/cmp"

	"userclouds.com/infra/namespace/universe"
	"userclouds.com/infra/pagination"
	"userclouds.com/infra/secret"
	"userclouds.com/infra/ucdb"
	"userclouds.com/infra/ucerr"
	"userclouds.com/infra/uclog"
	"userclouds.com/internal/companyconfig"
	tenantProvisioning "userclouds.com/internal/provisioning/tenant"
	"userclouds.com/internal/provisioning/types"
	"userclouds.com/internal/tenantdb"
	"userclouds.com/internal/tenantplex"
	"userclouds.com/plex/manager"
)

func loadTenants(ctx context.Context, ps *types.ProvisionerState) []types.TenantFile {
	if ps.IsTargetAll() {
		// Load all tenants from DB
		tenants := []companyconfig.Tenant{}

		pager, err := companyconfig.NewTenantPaginatorFromOptions(
			pagination.Limit(pagination.MaxLimit))
		if err != nil {
			uclog.Fatalf(ctx, "error applying pagination options: %v", err)
		}

		for {
			ts, respFields, err := ps.CompanyStorage.ListTenantsPaginated(ctx, *pager)
			if err != nil {
				uclog.Fatalf(ctx, "error listing tenants: %v", err)
			}

			tenants = append(tenants, ts...)

			if !pager.AdvanceCursor(*respFields) {
				break
			}
		}
		return makeTenantFilesFromTenants(ctx, ps, tenants)
	}

	if id := ps.GetUUIDTarget(); !id.IsNil() {
		// Load single tenant from DB
		tenant, err := ps.CompanyStorage.GetTenant(ctx, id)
		if err != nil {
			uclog.Fatalf(ctx, "failed to get existing tenant with id %s: %v", id, err)
		}
		return makeTenantFilesFromTenants(ctx, ps, []companyconfig.Tenant{*tenant})
	}

	// Load single tenant from file
	var provData types.TenantFile
	if err := loadFile(ps.Target, &provData); err != nil {
		uclog.Fatalf(ctx, "failed to load tenant provisioning file: %v", err)
	}
	// we used to validate the tenant URL in the file matches the autogenerated one here,
	// but we explicitly don't do that anymore so things like console can not be userclouds-console.tenant...
	return []types.TenantFile{provData}
}

func makeTenantFilesFromTenants(ctx context.Context, ps *types.ProvisionerState, tenants []companyconfig.Tenant) []types.TenantFile {
	tenantFiles := []types.TenantFile{}
	for _, tenant := range tenants {
		mgr, err := manager.NewFromCompanyConfig(ctx, ps.CompanyStorage, tenant.ID, nil)
		if err != nil {
			uclog.Errorf(ctx, "could not connect to tenant '%s' (id: %s) database: %v", tenant.Name, tenant.ID, err)
			promptToDeleteTenant(ctx, ps, tenant, "de-provision")
			continue
		}
		tenantPlex, err := mgr.GetTenantPlex(ctx, tenant.ID)
		if err != nil {
			uclog.Errorf(ctx, "tenant '%s' (id: %s) has no Plex data: %v", tenant.Name, tenant.ID, err)
			// Offer to delete tenant but continue process
			promptToDeleteTenant(ctx, ps, tenant, "de-provision")
			continue
		}
		tenantFiles = append(tenantFiles, types.TenantFile{
			Tenant:     tenant,
			PlexConfig: tenantPlex.PlexConfig,
			Protocol:   "unused",
			SubDomain:  "unused",
		})
	}
	return tenantFiles
}

// Note: action here is a string with a constant sentinel value for nuke to make it a little harder
// to accidentally pass the wrong bool and get catastrophic behavior
func promptToDeleteTenant(ctx context.Context, ps *types.ProvisionerState, tenant companyconfig.Tenant, action string) {
	if ps.Simulate {
		uclog.Fatalf(ctx, "trying to delete in simluate mode means we hit an error")
	}
	if types.ConfirmOperation(fmt.Sprintf("%s tenant '%s' (id: %s)", action, tenant.Name, tenant.ID)) {
		// NOTE: the plex & user store configs are empty because we don't need them to be valid to delete the tenant, just to [re]provision.
		pt, err := tenantProvisioning.NewProvisionableTenant(ctx, "CMD DeleteTenant Prompt", &tenant, nil, ps.CompanyStorage, ps.CompanyConfigDBCfg, ps.CompanyConfigDBCfg, ps.StatusDBCfg, nil, []uuid.UUID{})
		if err != nil {
			uclog.Errorf(ctx, "failed to prepare tenant '%s' (id: %s) for cleanup: %v", tenant.Name, tenant.ID, err)
			return
		}

		if action == "NUKE" {
			// belt & suspenders check
			if !universe.Current().IsDev() {
				uclog.Fatalf(ctx, "can't nuke in non-dev universes")
			}
			err = pt.Nuke(ctx)
		} else {
			err = pt.Cleanup(ctx)
		}

		if err != nil {
			uclog.Errorf(ctx, "tried but failed to %s tenant '%s' (id: %s): %v", action, tenant.Name, tenant.ID, err)
		} else {
			uclog.Infof(ctx, "%sd tenant '%s' (id: %s)", action, tenant.Name, tenant.ID)
		}
	}
}

func provisionTenants(ctx context.Context, ps *types.ProvisionerState, tenantFiles []types.TenantFile, validateOnly bool) {
	provs := make([]types.Provisionable, 0)
	for _, provData := range tenantFiles {
		uclog.Infof(ctx, "Tenant DB Config %v", provData.TenantDBCfg)
		if wp, err := setupTenantProvisioner(ctx, ps, provData); err != nil {
			uclog.Errorf(ctx, "failed to provision tenant '%s' (id: %s): %v", provData.Tenant.Name, provData.Tenant.ID, err)
			promptToDeleteTenant(ctx, ps, provData.Tenant, "de-provision")
		} else {
			if wp != nil {
				provs = append(provs, wp)
			}
		}
	}

	pos := []types.ProvisionOperation{types.Provision, types.Close}
	if validateOnly {
		pos = []types.ProvisionOperation{types.Validate, types.Close}
	}
	bp, err := types.NewBatchProvisioner("ProvTenantsCMD", provs, 10)
	if err != nil {
		uclog.Fatalf(ctx, "could not initialize batch provisioner: %v", err)
	}

	hadErrors := false
	if err := bp.Execute(ctx, pos); err != nil {
		for _, p := range provs {
			wpt, ok := p.(*tenantProvisionerCmdWrapper)
			if !ok {
				uclog.Errorf(ctx, "Unexpected provisionable in top level array %v", p)
				hadErrors = true
				continue
			}

			for _, po := range pos {
				if err := wpt.GetErrorForOperation(po); err != nil {
					uclog.Errorf(ctx, "Tenant %v failed to %v for %s with %v", wpt.Name(), po, ucerr.UserFriendlyMessage(err), err)
					hadErrors = true
				}

			}
		}
	}
	if hadErrors {
		uclog.Fatalf(ctx, "failed to provision some tenants")
	}
}

func deprovisionTenants(ctx context.Context, ps *types.ProvisionerState, tenantFiles []types.TenantFile) {
	for _, provData := range tenantFiles {
		promptToDeleteTenant(ctx, ps, provData.Tenant, "de-provision")
	}
}

func nukeTenants(ctx context.Context, ps *types.ProvisionerState, tenantFiles []types.TenantFile) {
	for _, provData := range tenantFiles {
		promptToDeleteTenant(ctx, ps, provData.Tenant, "NUKE")
	}
}

func setupTenantProvisioner(ctx context.Context, ps *types.ProvisionerState, provData types.TenantFile) (types.Provisionable, error) {
	if err := provData.Validate(); err != nil {
		return nil, ucerr.Errorf("tenant failed basic validation: %v", err)
	}

	if ps.Simulate {
		uclog.Infof(ctx, "successfully simulated provisioning tenant '%s' (id: %s)", provData.Tenant.Name, provData.Tenant.ID)
		return nil, nil
	}

	// does the company exist?
	if _, err := ps.CompanyStorage.GetCompany(ctx, provData.Tenant.CompanyID); err != nil {
		return nil, ucerr.Errorf("failed to load company %v referenced by tenant %v: %w",
			provData.Tenant.CompanyID,
			provData.Tenant.ID,
			err)
	}

	// Check for a conflicting domain on a different ID
	// We strip the protocol so we can use the Host method here (that we use for multitenant
	// middleware etc) rather than maintaining a separate storage method just for this
	host := provData.Tenant.GetHostName()
	existing, err := ps.CompanyStorage.GetTenantByHost(ctx, host)
	if err == nil && existing.ID != provData.Tenant.ID {
		uclog.Infof(ctx, "found tenant %v with matching domain (%v) and different ID", existing.ID, existing.TenantURL)
		uclog.Infof(ctx, "this will conflict with your new tenant %v", provData.Tenant.ID)
		if types.ConfirmOperationForProd(fmt.Sprintf("do you want to delete the conflicting tenant %v", existing.ID)) {
			if err := ps.CompanyStorage.DeleteTenant(ctx, existing.ID); err != nil {
				return nil, ucerr.Errorf("error deleting conflicting domain tenant %v: %w", existing.ID, err)
			}
		}
	}
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		// unlikely but easier for future me to debug if we check now
		return nil, ucerr.Errorf("failed to check for existing tenant by URL: %w", err)
	}

	// now check for a "conflicting" ID (this is quite possibly existing, above, but maybe not)
	tenant, err := ps.CompanyStorage.GetTenant(ctx, provData.Tenant.ID)
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return nil, ucerr.Errorf("error checking for existing tenant ID %v: %w", provData.Tenant.ID, err)
	}

	// if we loaded it, do we overwrite?
	var existingInternal *companyconfig.TenantInternal
	var existingPlex *tenantplex.TenantPlex
	var expectedTenantToBeEqual bool // we'll use this for TenantInternal as well
	var expectedPlexToBeEqual bool
	var expectedUserStoreToBeEqual bool

	if err == nil {
		uclog.Infof(ctx, "Matching tenant exists: %v", tenant)
		expectedTenantToBeEqual = true
		expectedPlexToBeEqual = true
		expectedUserStoreToBeEqual = true

		existingInternal, err = ps.CompanyStorage.GetTenantInternal(ctx, provData.Tenant.ID)
		if err != nil {
			// this shouldn't fail since we have a Tenant record, but not fatal if it does
			uclog.Errorf(ctx, "couldn't load TenantInternal for %v despite having Tenant: %v", provData.Tenant.ID, err)
		}

		if !cmp.Equal(*tenant, provData.Tenant, ignoreTimes()) {
			uclog.Infof(ctx, "found existing tenant for ID %v (- existing, + new)...\n%s", tenant.ID, cmp.Diff(*tenant, provData.Tenant, ignoreTimes()))
			if types.ConfirmOperation("overwrite existing tenant with new data") {
				if err := ps.CompanyStorage.SaveTenant(ctx, &provData.Tenant); err != nil {
					return nil, ucerr.Errorf("error updating tenant %v: %w", tenant.ID, err)
				}
				expectedTenantToBeEqual = false
			}
		}

		// this is duplicative with ProvisionTenant (which will always overwrite),
		// but in the CLI case this lets you bail if you didn't want to.
		mgr, err := manager.NewFromCompanyConfig(ctx, ps.CompanyStorage, provData.Tenant.ID, nil)
		if err != nil {
			return nil, ucerr.Wrap(err)
		}
		existingPlex, err = mgr.GetTenantPlex(ctx, provData.Tenant.ID)

		// preserve existing login apps that aren't in the provData config
		for _, existingApp := range existingPlex.PlexConfig.PlexMap.Apps {
			if _, _, err := provData.PlexConfig.PlexMap.FindAppForClientID(existingApp.ClientID); err != nil {
				provData.PlexConfig.PlexMap.Apps = append(provData.PlexConfig.PlexMap.Apps, existingApp)
			}
		}

		if err != nil {
			// Exclude ErrNoRows in case we have a partially-provisioned tenant
			if !errors.Is(err, sql.ErrNoRows) {
				return nil, ucerr.Errorf("error loading existing tenant (%v) plex config: %w", provData.Tenant.ID, err)
			}

			// if partially provisioned, we'll create the plex config
			existingPlex = &tenantplex.TenantPlex{
				VersionBaseModel: ucdb.NewVersionBaseWithID(provData.Tenant.ID),
				PlexConfig:       provData.PlexConfig,
			}
		} else if !cmp.Equal(existingPlex.PlexConfig,
			provData.PlexConfig,
			cmp.AllowUnexported(secret.String{})) {

			uclog.Infof(ctx, "existing tenant %v has differing plex configs (- existing, + new)...\n%s", provData.Tenant.ID,
				cmp.Diff(existingPlex.PlexConfig, provData.PlexConfig, cmp.AllowUnexported(secret.String{})))
			if types.ConfirmOperation("overwrite existing plex config with new data") {
				existingPlex.PlexConfig = provData.PlexConfig
				if err := mgr.SaveTenantPlex(ctx, existingPlex); err != nil {
					return nil, ucerr.Errorf("error updating tenant plex config: %w", err)
				}
				expectedPlexToBeEqual = false
			} else {
				uclog.Infof(ctx, "provisioning.ProvisionTenant will overwrite plex config, so we're aborting now...")
				return nil, nil
			}
		}
	} else {
		// Turn on online provisioning mode since we're creating a tenant for the first time
		types.ProvisionMode = types.OnlineProvisionMode

		// didn't load an existing tenant (plex), so we'll create a new one
		existingPlex = &tenantplex.TenantPlex{
			VersionBaseModel: ucdb.NewVersionBaseWithID(provData.Tenant.ID),
			PlexConfig:       provData.PlexConfig,
		}
	}

	// if we got this far, provision the tenant like new
	pt, err := tenantProvisioning.NewProvisionableTenant(ctx,
		"ProvCMD",
		&provData.Tenant,
		existingPlex,
		ps.CompanyStorage,
		ps.CompanyConfigDBCfg,
		provData.TenantDBCfg,
		ps.StatusDBCfg,
		nil,
		[]uuid.UUID{},
	)
	if err != nil {
		return nil, ucerr.Wrap(err)
	}

	wp := tenantProvisionerCmdWrapper{
		Named:                      types.NewNamed(provData.Tenant.ID.String()),
		Parallelizable:             types.AllParallelizable(),
		storage:                    ps.CompanyStorage,
		provData:                   &provData,
		p:                          pt,
		existingTenant:             existing,
		existingInternal:           existingInternal,
		existingPlex:               existingPlex,
		expectedTenantToBeEqual:    expectedTenantToBeEqual,
		expectedPlexToBeEqual:      expectedPlexToBeEqual,
		expectedUserStoreToBeEqual: expectedUserStoreToBeEqual,
		errorMap:                   make(map[types.ProvisionOperation]error),
	}
	return &wp, nil
}

// tenantProvisionerCmdWrapper is a Provisionable object used to enable provisioning tenants in parallel
type tenantProvisionerCmdWrapper struct {
	types.Named
	types.Parallelizable
	storage  *companyconfig.Storage
	provData *types.TenantFile
	p        *tenantProvisioning.ProvisionableTenant

	existingTenant   *companyconfig.Tenant
	existingInternal *companyconfig.TenantInternal
	existingPlex     *tenantplex.TenantPlex

	expectedTenantToBeEqual    bool
	expectedPlexToBeEqual      bool
	expectedUserStoreToBeEqual bool

	errorMap map[types.ProvisionOperation]error

	screenOutputLock sync.Mutex
}

// Provision implements Provisionable
func (wt *tenantProvisionerCmdWrapper) Provision(ctx context.Context) error {
	uclog.Infof(ctx, "Provisioning tenant %v (%v)", wt.provData.Tenant.Name, wt.provData.Tenant.ID)
	if err := wt.p.Provision(ctx); err != nil {
		wt.errorMap[types.Provision] = err
		return ucerr.Wrap(err)
	}
	return nil
}

// Validate implements Provisionable
func (wt *tenantProvisionerCmdWrapper) Validate(ctx context.Context) error {
	// TODO we previosly skipped validation during cmd provisioning
	if err := wt.p.Validate(ctx); err != nil {
		wt.errorMap[types.Validate] = err
		return ucerr.Wrap(err)
	}

	// safety: check what's there now and display a diff
	gotTenant, err := wt.storage.GetTenant(ctx, wt.provData.Tenant.ID)
	if err != nil {
		return ucerr.Wrap(err)
	}
	gotInternal, err := wt.storage.GetTenantInternal(ctx, wt.provData.Tenant.ID)
	if err != nil {
		return ucerr.Wrap(err)
	}
	tenantDB, err := tenantdb.ConnectWithConfig(ctx, &wt.existingInternal.TenantDBConfig)
	if err != nil {
		return ucerr.Wrap(err)
	}
	mgr := manager.NewFromDB(tenantDB, nil)
	gotPlex, err := mgr.GetTenantPlex(ctx, wt.provData.Tenant.ID)
	if err != nil {
		return ucerr.Wrap(err)
	}

	// safety: check what's there now and display a diff, don't interleave the output across tenants
	wt.screenOutputLock.Lock()
	defer wt.screenOutputLock.Unlock()

	if cmp.Equal(wt.existingTenant, gotTenant, ignoreTimes()) != wt.expectedTenantToBeEqual {
		uclog.Infof(ctx, "%v: AFTER SAVE: new tenant was changed (- existing, + new):\n%s", wt.provData.Tenant.ID, cmp.Diff(wt.existingTenant, gotTenant, ignoreTimes()))
		uclog.Infof(ctx, "If you didn't expect this, you should probably debug now.")
	}

	if cmp.Equal(wt.existingInternal, gotInternal, ignoreTimes(), cmp.AllowUnexported(secret.String{})) != wt.expectedTenantToBeEqual {
		uclog.Infof(ctx, "%v:mAFTER SAVE: new tenant internal was changed (- existing, + new):\n%s", wt.provData.Tenant.ID,
			cmp.Diff(wt.existingInternal, gotInternal, ignoreTimes(), cmp.AllowUnexported(secret.String{})))
		uclog.Infof(ctx, "If you didn't expect this, you should probably debug now.")
	}

	if cmp.Equal(wt.existingPlex, gotPlex, ignoreTimes(), cmp.AllowUnexported(secret.String{})) != wt.expectedPlexToBeEqual {
		uclog.Infof(ctx, "%v: AFTER SAVE: new tenant plex was changed (- existing, + new):\n%s", wt.provData.Tenant.ID,
			cmp.Diff(wt.existingPlex, gotPlex, ignoreTimes(), cmp.AllowUnexported(secret.String{})))
		uclog.Infof(ctx, "If you didn't expect this, you should probably debug now.")
	}
	return nil
}

// Cleanup implements Provisionable
func (wt *tenantProvisionerCmdWrapper) Cleanup(ctx context.Context) error {
	if err := wt.p.Cleanup(ctx); err != nil {
		wt.errorMap[types.Cleanup] = err
		return ucerr.Wrap(err)
	}
	return nil
}

// Close cleans up resources that maybe used by a TenantProvisionerCmdWrapper
func (wt *tenantProvisionerCmdWrapper) Close(ctx context.Context) error {
	if err := wt.p.Close(ctx); err != nil {
		return ucerr.Wrap(err)
	}
	return nil
}

func (wt *tenantProvisionerCmdWrapper) GetErrorForOperation(op types.ProvisionOperation) error {
	return ucerr.Wrap(wt.errorMap[op])
}
